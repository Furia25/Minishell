					/* -Fonctions pipex: */

// dup:

#include <unistd.h>
int dup(int oldfd);

/* Explication :
oldfd : descripteur de fichier existant que l'on souhaite dupliquer.
Retourne un nouveau descripteur de fichier qui est la plus petite valeur disponible.
En cas d'√©chec, retourne -1 et errno est d√©fini pour indiquer l'erreur.

Fonctionnement :
Le nouveau descripteur de fichier et oldfd partagent la m√™me table des descripteurs ouverts.
Ils pointent vers le m√™me fichier sous-jacent et partagent le m√™me offset (position de lecture/√©criture).
La fermeture de l'un n'affecte pas l'autre tant qu'au moins un descripteur reste ouvert. */

// dup2:

#include <unistd.h>
int dup2(int oldfd, int newfd);

/* Explication des param√®tres :
oldfd : descripteur de fichier existant que l'on souhaite dupliquer.
newfd : valeur du descripteur de fichier o√π l'on veut copier oldfd.
Comportement de dup2 :
Si newfd est d√©j√† ouvert, il est ferm√© automatiquement avant d'√™tre r√©assign√© √† oldfd (sauf si newfd == oldfd).
newfd devient une copie exacte de oldfd, partageant la m√™me table des fichiers ouverts et la m√™me position de lecture/√©criture.
Retourne newfd en cas de succ√®s ou -1 en cas d'erreur (errno est d√©fini). */

// execve:

#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);

/* Param√®tres :
pathname : chemin absolu ou relatif du fichier ex√©cutable √† ex√©cuter.
argv : tableau de pointeurs vers les arguments du programme (le premier argument est g√©n√©ralement le nom du programme).
envp : tableau de pointeurs vers les variables d‚Äôenvironnement (peut √™tre NULL pour h√©riter de celles du processus parent).
Comportement de execve :
Si execve r√©ussit :
Il remplace le processus appelant par le programme sp√©cifi√©.
Il ne retourne jamais (sauf en cas d'erreur).
Si execve √©choue :
Il retourne -1 et d√©finit errno pour indiquer l'erreur. */


// fork :

#include <unistd.h>
#include <sys/types.h>
pid_t fork(void);

/* Retour de fork()
Dans le processus parent : fork() retourne le PID du processus enfant (valeur > 0).
Dans le processus enfant : fork() retourne 0.
En cas d'√©chec : fork() retourne -1, et errno est d√©fini pour indiquer l'erreur.
Fonctionnement de fork()
Le processus appelant (parent) ex√©cute fork().
Un nouveau processus enfant est cr√©√© :
Espace m√©moire : Le processus enfant h√©rite des variables du parent (variables globales, variables locales dans les fonctions appel√©es avant le fork(), etc.), mais dans un premier temps, la m√©moire est copi√©e (ce qu'on appelle une copie sur demande ou copy-on-write). Cela signifie que, bien que le parent et l'enfant aient une copie de la m√©moire, ils n'interf√®rent pas l'un avec l'autre.
Descripteurs de fichiers : Les descripteurs de fichiers ouverts avant le fork() (par exemple, pour des fichiers, des pipes ou des sockets) sont partag√©s entre le parent et l'enfant. Cela signifie que les deux processus peuvent lire ou √©crire dans les m√™mes fichiers ou tubes (pipes).
Si un des deux processus ferme son descripteur de fichier (par exemple, avec close()), cela n'affecte pas l'autre processus, car ils ont des copies distinctes de ces descripteurs de fichiers (bien que le descripteur lui-m√™me soit identique).
Il a un PID unique et un PPID (Parent Process ID) qui correspond au PID du parent.
fork() retourne diff√©remment dans chaque processus :
Le parent re√ßoit le PID de l‚Äôenfant.
L‚Äôenfant re√ßoit 0.
Le parent continue son ex√©cution ind√©pendamment de l‚Äôenfant.
En cas d‚Äô√©chec, le parent re√ßoit -1 et aucun enfant n'est cr√©√©. */

//avec fork le processus enfant obtient une copie du pointeur vers la struct associ√© a un fichier d√©sign√© par un fd (meme fd mais le close nimpacte pas lautre)
//avec dup2 envoie newfd qui designe un int representant un pointeur vers la structure associ√© √° oldfd

// wait:

/* La fonction wait() en C est utilis√©e pour synchroniser un processus parent avec son (ou ses) processus enfant. Elle permet au parent d‚Äôattendre que l‚Äôun de ses enfants se termine et de r√©cup√©rer son code de retour. */

#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
pid_t wait(int *wstatus);

/* Valeur de retour de wait()
Si un enfant se termine, wait() retourne son PID.
Si aucune erreur, mais pas d‚Äôenfant √† attendre, wait() bloque l‚Äôex√©cution du parent jusqu‚Äô√† la fin d‚Äôun enfant.
Si une erreur survient, wait() retourne -1 et d√©finit errno.
Param√®tre wstatus
I:PORAMTANT >>>> https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff
wstatus permet de r√©cup√©rer l‚Äô√©tat de terminaison du processus enfant.
Si wstatus est NULL, le parent attend juste sans r√©cup√©rer d‚Äôinformations. */

// waitpid

/*La fonction waitpid() en C est une version am√©lior√©e de wait() qui permet d‚Äôattendre un processus sp√©cifique ou n‚Äôimporte quel enfant avec plus de contr√¥le. */

#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
pid_t waitpid(pid_t pid, int *wstatus, int options);

/* Param√®tres
pid : Permet de pr√©ciser quel processus attendre :

> 0 : Attend le processus avec ce PID pr√©cis.
-1 : Se comporte comme wait() et attend n‚Äôimporte quel enfant.
0 : Attend n‚Äôimporte quel enfant du m√™me groupe.
< -1 : Attend n‚Äôimporte quel enfant d‚Äôun groupe sp√©cifique (PID absolu comme GID n√©gatif).
wstatus : Adresse d‚Äôun entier o√π waitpid() stocke le statut de terminaison.

Peut √™tre NULL si on ne veut pas r√©cup√©rer d‚Äôinformations.
options : Contr√¥le le comportement :

0 : Bloque jusqu‚Äô√† ce qu‚Äôun enfant se termine.
WNOHANG : Ne bloque pas, retourne imm√©diatement si aucun enfant termin√©.
WUNTRACED : Retourne aussi si un enfant est stopp√© (ex: SIGSTOP).
WCONTINUED : Retourne si un enfant a √©t√© repris (SIGCONT).
Valeur de retour
Retourne le PID du processus termin√©.
Retourne 0 si WNOHANG est utilis√© et qu‚Äôaucun enfant n‚Äôest encore termin√©.
Retourne -1 en cas d‚Äôerreur (ex: mauvais PID ou aucun enfant). */

//pipe

/* La fonction pipe() en C est utilis√©e pour cr√©er un tube de communication inter-processus (IPC) permettant √† un processus d‚Äôenvoyer des donn√©es √† un autre via un canal unidirectionnel.
Si l'enfant tente de lire (read()) alors que le parent n'a pas encore √©crit (write()), il sera bloqu√© jusqu'√† ce qu'il y ait des donn√©es √† lire. */

#include <unistd.h>
int pipe(int pipefd[2]);

/* Param√®tre
pipefd[2] : Un tableau d‚Äôentiers o√π pipefd[0] est utilis√© pour lire et pipefd[1] pour √©crire.
Valeur de retour
0 : Succ√®s.
-1 : Erreur (ex: trop de tubes ouverts, m√©moire insuffisante).

pipe() avec dup2() pour rediriger stdout */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipefd[2];
    char buffer[100];

    // Cr√©ation du tube (pipe)
    if (pipe(pipefd) == -1) {
        perror("Erreur lors de la cr√©ation du pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if (pid < 0) {
        perror("Erreur lors du fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {  // Processus enfant
        close(pipefd[0]);  // Fermer la lecture du pipe (inutile pour l'enfant)

        // Rediriger stdout (sortie stand0ard) vers le pipe
        dup2(pipefd[1], STDOUT_FILENO);
        close(pipefd[1]);  // Fermer l'ancien descripteur d'√©criture du pipe

        // Ex√©cuter une commande dont la sortie sera redirig√©e vers le pipe
        execlp("ls", "ls", "-l", NULL);

        // Si execlp √©choue :
        perror("Erreur lors de l'ex√©cution de ls");
        exit(EXIT_FAILURE);
    } else {  // Processus parent
        close(pipefd[1]);  // Fermer l'√©criture du pipe (inutile pour le parent)

        // Lire la sortie du pipe et l'afficher
        ssize_t count;
        while ((count = read(pipefd[0], buffer, sizeof(buffer) - 1)) > 0) {
            buffer[count] = '\0';  // Ajouter un caract√®re nul pour bien afficher
            printf("Parent a lu :\n%s", buffer);
        }

        close(pipefd[0]);  // Fermer la lecture du pipe
    }

    return 0;
}

/* Redirige la sortie de ls -l vers le parent ! */

//unlink

/* La fonction unlink() est utilis√©e pour supprimer un fichier d'un syst√®me de fichiers sous Linux/Unix. Cependant, elle fonctionne diff√©remment de rm en ligne de commande car elle agit sur les liens et les inodes des fichiers.
unlink va supprimer un fichier une fois que tout les porcessus utilisant ce fichier le ferme */

#include <unistd.h>
int unlink(const char *pathname);

/* pathname : Le chemin du fichier √† supprimer.
Retourne 0 en cas de succ√®s, -1 en cas d‚Äô√©chec et remplit errno avec le code d'erreur.

Comment fonctionne unlink() ?
Lorsqu'un fichier est cr√©√© sur un syst√®me de fichiers Unix/Linux, il poss√®de :

Un inode (stocke les m√©tadonn√©es du fichier).
Un ou plusieurs liens (hard links) qui pointent vers cet inode.
unlink() ne supprime pas imm√©diatement les donn√©es du fichier !
Il supprime un lien pointant vers l‚Äôinode.
Si aucun lien n‚Äôexiste, l‚Äôinode et ses donn√©es sont effac√©s du disque.
Si un autre processus utilise encore ce fichier (ex: un programme l‚Äôa ouvert avec open()), le fichier n‚Äôest supprim√© qu‚Äôapr√®s la fermeture.

Cas particuliers
Suppression d'un fichier en cours d'utilisation
Si un fichier est ouvert par un programme :

unlink() supprime le lien, mais pas le fichier imm√©diatement.
Le fichier reste accessible tant que le programme le garde ouvert.
Lorsque tous les processus ont ferm√© le fichier, l‚Äôinode et les donn√©es sont r√©ellement supprim√©s.*/

// access

/* La fonction access() permet de v√©rifier les permissions d'acc√®s √† un fichier ou un r√©pertoire sans l'ouvrir ni le modifier. */

#include <unistd.h>
int access(const char *pathname, int mode);

/* Param√®tres :
pathname ‚Üí Nom du fichier ou r√©pertoire √† v√©rifier.
mode ‚Üí Type d'acc√®s que l'on souhaite tester :
F_OK ‚Üí V√©rifie si le fichier existe.
R_OK ‚Üí V√©rifie si le fichier est lisible (Read).
W_OK ‚Üí V√©rifie si le fichier est √©crivable (Write).
X_OK ‚Üí V√©rifie si le fichier est ex√©cutable (Execute).
Valeur de retour :
0 ‚Üí L'acc√®s est autoris√©.
-1 ‚Üí L'acc√®s est refus√© (et errno est d√©fini avec la cause). */

                /* Gestion de l'historique */

// readline

/* La fonction readline() fait partie de la GNU Readline Library. Son but est de lire une ligne de texte depuis l'entr√©e standard avec des fonctionnalit√©s avanc√©es (√©dition de ligne, historique, autocompl√©tion...). */

#include <readline/readline.h>
char *readline(const char *prompt);

/* prompt ‚Üí La cha√Æne affich√©e avant que l'utilisateur entre du texte (ex: "> ").
Retourne une cha√Æne allou√©e dynamiquement contenant l'entr√©e utilisateur.
Retourne NULL si un EOF (Ctrl+D) est d√©tect√©.

√âtapes internes de readline()
1Ô∏è‚É£ Affichage du prompt
Lorsqu'on appelle readline(">>> "), la fonction :

- Affiche le prompt sans ajouter de \n.
- Passe en mode lecture interactive, o√π elle attend que l'utilisateur tape quelque chose.
2Ô∏è‚É£ Lecture interactive et √©dition en direct
L'utilisateur tape son texte, qui est stock√© dans un buffer interne.
Pendant qu'il tape, Readline lui permet d'√©diter sa ligne :
Effacer avec Backspace
D√©placer le curseur avec ‚Üê et ‚Üí
Autocompl√©tion avec Tab
Historique avec ‚Üë et ‚Üì
√Ä ce moment-l√†, la ligne n'est pas encore retourn√©e au programme.
-Fl√®che gauche/droite : D√©placement du curseur.
-Fl√®che haut/bas : Parcourir l'historique.
-Backspace / Delete : Suppression de caract√®res.
-Ctrl+U : Effacer toute la ligne.
-Ctrl+W : Supprimer le mot pr√©c√©dent.
3 L'utilisateur appuie sur Entr√©e (\n)
La ligne est finalis√©e et stock√©e dans un nouveau buffer en m√©moire.
Readline retourne un pointeur sur cette nouvelle cha√Æne.
Le buffer interne est vid√© et Readline est pr√™t √† en recevoir une nouvelle.

//add_history

/* readline() ne stocke pas l'historique tout seul ! Il faut ajouter les lignes avec :

add_history(input);
üîπ Comment √ßa marche ?

readline() ne retient pas les commandes pr√©c√©dentes par d√©faut.
add_history(input) ajoute la ligne √† la liste d‚Äôhistorique.
Une fois ajout√©e, fl√®che haut/bas permet de naviguer entre les anciennes commandes.*/

#include <readline/readline.h>
#include <readline/history.h>

void add_history(const char *line);


//rl_clear_history

/* La fonction rl_clear_history() fait partie de la biblioth√®que GNU Readline et permet de vider compl√®tement l'historique des commandes stock√© en m√©moire. */


#include <readline/readline.h>
#include <readline/history.h>
void rl_clear_history(void);

/* Effet : Efface toutes les entr√©es stock√©es dans l'historique Readline. */

//rl_on_new_line

/* Avant l'appel de rl_on_new_line(), l'utilisateur tape une commande et voit son texte dans le terminal.

Lors de l'appel de rl_on_new_line() :

Le prompt est d√©plac√© sur une nouvelle ligne.
Le curseur (qui est l'endroit o√π l'utilisateur tape) est d√©plac√© juste apr√®s le prompt, pr√™t √† recevoir de nouvelles saisies.
La ligne actuelle en cours d'√©dition (dans le buffer de Readline) est termin√©e et consid√©r√©e comme "finie" pour toute nouvelle saisie.
Ce que cela signifie visuellement :

Un nouveau prompt ($>) s'affiche sur une nouvelle ligne.
Le curseur est d√©plac√© juste apr√®s ce prompt, pr√™t √† recevoir une nouvelle entr√©e de l'utilisateur.
Effet sur le buffer :

Apr√®s l'appel de rl_on_new_line(), le buffer interne (qui contient le texte de l'ancienne ligne) est marqu√© comme √©tant "termin√©" ou ignor√©, mais ne dispara√Æt pas. La ligne que l'utilisateur commence √† taper √©crasera le contenu du buffer. */

#include <readline/readline.h>
#include <readline/history.h>
void rl_on_new_line(void);

/* Fonctionnement d√©taill√© de rl_on_new_line()

But principal :

La fonction rl_on_new_line() indique √† la biblioth√®que Readline que le curseur est sur une nouvelle ligne. Cela peut affecter la mani√®re dont les entr√©es pr√©c√©dentes (l'historique des commandes) sont affich√©es ou rafra√Æchies.

Contexte d'utilisation :

Lorsqu'un utilisateur entre du texte dans un terminal interactif, Readline g√®re l'affichage de l'invite et du texte saisi. Si une ligne est longue et que l'utilisateur d√©place le curseur √† une nouvelle ligne, cela peut affecter l'affichage de la ligne courante.
rl_on_new_line() est utilis√©e pour forcer le d√©marrage d'une nouvelle ligne, garantissant ainsi que l'affichage soit correct.

Pourquoi utiliser rl_on_new_line() ?

Elle peut √™tre utile dans des cas o√π le comportement de l'affichage pourrait √™tre ambigu, en particulier lorsque le texte est affich√© sur plusieurs lignes et qu'il faut forcer un retour √† la ligne sans affecter les lignes suivantes.
En effet, la fonction nettoie la gestion de l'affichage du texte dans le terminal lorsque l'on passe √† une nouvelle ligne.

l'autocompletion est gere automatiquement par readine!!!!!!! */

//rl_replace_line

#include <readline/readline.h>
#include <readline/history.h>
void rl_replace_line(const char *text, int clear_undo);

/* Param√®tres :
text : C'est le texte qui va remplacer la ligne actuelle dans le buffer de Readline. Ce texte remplace le contenu que l'utilisateur avait saisi jusqu'√† ce point. Apr√®s l'appel √† rl_replace_line(), ce texte sera affich√© √† la place de l'ancienne ligne lorsqu'on redessine l'√©cran (avec rl_redisplay() par exemple).

clear_undo : C'est un entier qui d√©termine si l'historique des modifications de la ligne doit √™tre effac√©. Si la valeur est non nulle, l'historique des modifications de la ligne (undo) est effac√©, ce qui signifie que l'utilisateur ne pourra pas annuler cette modification

Comportement :
Modification du buffer interne : Lorsque tu appelles rl_replace_line(), le texte que tu fournis en param√®tre va remplacer le texte actuellement stock√© dans le buffer interne de Readline. Ce buffer interne est utilis√© pour g√©rer la ligne de texte que l'utilisateur √©dite dans le terminal.

Pas d'affichage imm√©diat : L'appel √† rl_replace_line() ne met pas imm√©diatement √† jour l'affichage du terminal. Pour cela, tu dois utiliser rl_redisplay() apr√®s avoir remplac√© la ligne pour qu'elle soit redessin√©e √† l'√©cran. Si tu ne fais pas √ßa, le texte remplac√© ne sera pas visible dans le terminal.

 */

// rl_redisplay

/* Pr√©sentation g√©n√©rale de rl_redisplay() :
rl_redisplay() est une fonction fournie par la biblioth√®que Readline qui permet de rafra√Æchir et r√©afficher le contenu de la ligne en cours d'√©dition dans le terminal. Elle est souvent utilis√©e pour mettre √† jour l'affichage de la ligne d'entr√©e lorsque le contenu du buffer interne change, ou apr√®s une op√©ration de modification de la ligne (comme l'insertion ou l'effacement de caract√®res).

Quand est-ce qu'on utilise rl_redisplay() ?
Il est particuli√®rement utile dans les situations suivantes :

Apr√®s une modification manuelle du buffer (par exemple, lorsque tu utilises rl_replace_line() pour remplacer la ligne).
Apr√®s un √©v√©nement qui modifie le contenu de la ligne, mais o√π tu veux que l'utilisateur voit imm√©diatement ces changements dans le terminal (par exemple, apr√®s avoir effectu√© un auto-compl√©tion ou une correction).
Comment rl_redisplay() fonctionne-t-il en pratique ?
Lorsqu'on appelle rl_redisplay(), la fonction va effectuer plusieurs actions en coulisse :

Elle va effacer la ligne actuelle √† l'√©cran.
Elle va r√©afficher le prompt.
Ensuite, elle va r√©afficher le contenu du buffer (rl_line_buffer) dans le terminal, √† partir de la position du curseur. */



/* A faire attention */
//echo caca>file.txt | cat
// grep "oui oui baguette"


//https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff

pour subshell utiliser isatty, check si ca ajoute a lhistorique





Cas limites √† tester :

    Cha√Æne vide :

        wildcard_matches("", "") ‚Üí true (OK)

        wildcard_matches("", "*") ‚Üí true (OK, car * peut correspondre √† 0 caract√®re)

        wildcard_matches("", "a") ‚Üí false (OK)

    Correspondance exacte :

        wildcard_matches("abc", "abc") ‚Üí true (OK)

    Wildcard ? :

        wildcard_matches("a", "?") ‚Üí true (OK)

        wildcard_matches("ab", "a?") ‚Üí true (OK)

        wildcard_matches("a", "??") ‚Üí false (OK)

    Wildcard * :

        wildcard_matches("abc", "*") ‚Üí true (OK)

        wildcard_matches("abc", "a*") ‚Üí true (OK)

        wildcard_matches("abc", "*c") ‚Üí true (OK)

        wildcard_matches("abc", "a*c") ‚Üí true (OK)

        wildcard_matches("abc", "a*d") ‚Üí false (OK)

    Backtracking complexe :

        wildcard_matches("mississippi", "m*iss*iss*") ‚Üí true (OK)

        wildcard_matches("axbxcxdxe", "a*b*c*d*e*") ‚Üí true (OK)

    Cas d'√©chec :

        wildcard_matches("abc", "abcd") ‚Üí false (OK)

        wildcard_matches("abc", "a?c?") ‚Üí false (OK)


- exit
- ENV _ < 
- signaux
- exec
- expansion et $?
- Wildcard .


t_hash_entry *test = hashmap_search(hash(expand), &data.environment);
	if (!test)
		return ()
t_envvar *test2 = (t_envvar *)test->value;
test2->name;